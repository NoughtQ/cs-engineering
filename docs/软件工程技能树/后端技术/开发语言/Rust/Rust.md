---
title: Rust
slug: Rust
sidebar_position: 3
---


# Rust

Author：NA

<div class="callout callout-bg-2 callout-border-2">
<div class='callout-emoji'>🤔</div>
<p>最近 Rust 似乎逐渐火起来了，Linux 也要把 Rust 的支持合入主线了。不少人都非常喜欢 Rust，也在宣传 Rust。不少公司也开始对 Rust 进行了种种支持：Amazon 有专门的 Rust 团队，微软官方也为 Rust 提供了文档。</p>
<p>这到底是怎么一回事呢？</p>
</div>

## 先说一些比较抽象的

任何新的解决方案，之所以被行业追捧，本质是因为它解决了先前未能解决的问题。k8s 规范化了工业中集群调度、服务发现等诸多热点问题，很多公司才对它趋之若鹜；golang 在简单、贴合大学教材的同时，做到了一定的安全、高效，所以各个公司的后端语言长期演进方向才都成为了 golang。在工业界获得广泛使用的解决方案，在学术角度不一定是完善的，甚至非常低级，但由于其对适用场景、市场的精确把控，使得它获得了成功。反过来说也一样，学术上非常先进的产品，也不一定被工业界认可。

## Rust 到底解决了什么问题？

看到这里，请大家想象一下，你正在看的这篇文章，是飞书提供的服务。飞书的这些前、后端服务，全部部署在了 Linux 服务器上。这样算下来，你每天间接使用 Linux 服务器的时长就有很多。那么，对世界如此重要的操作系统，Linux ，是用什么编程语言写的？C语言，准确来说是 C99（直到 2021 年还是这样）。即便 C 语言在 1999 年后发生了一些标准上的变化，Linux 后来也支持了新的 C 标准，但语言层面的变化仍然是很小的。

没错，在 2023 年，我们这个世界的很多基础设施，仍然都是使用 C ，这个 50 年前的老古董编写的。尽管存在一些标准层面的演进，但整体来说，C 语言的设计思维仍停留在 50 年前。在这 50 年间，很多新的思维、范式被工业界接受了，C 语言离现代开发的距离就越来越远。

- C 语言没有 “包” 的概念，有 “头文件” 的概念。
    - include 一个文件，仅仅是对文件的字面复制粘贴而已。这些字面的粘贴，以及各种宏在字面粘贴之外进行的文字游戏，使得编译器难以优化编译进程——或者说，难以进行合理的编译缓存。
    - 头文件里要重新抄写一遍向外部暴露的接口，这其实在编程语言的设计角度是没有必要的。
    - 没有包的概念，就没有一个稳定的分发方案。项目与各种动态链接库产生了依赖，但没有一个方式去描述这些依赖关系。这就导致，分发到客户设备上的代码，很有可能无法正常编译。

- C 语言纵容对内存的操作，且没有一种合理的方式/范式约束这种操作。
    - C 语言其实离汇编语言很近。很多人甚至觉得，C 语言仅仅是一个简化版的汇编语言而已，很少能看到高级语言而已。这种定位的语言，就非常方便对内存完全自由的控制，包括读写。
    - 人是会犯错的。所以如果给了人 malloc 和 free 的权力，那么他就有可能不释放内存空间，无论他是新手还是经验丰富的开发者。相同的问题还体现在变量所有权上，体现在变量是否有必要为 const 上。当然，大家归纳、总结以后，发现非常多场景下，由开发者直接操作裸内存是没有必要的——这些具备稳定需求的功能，完全可以封装成标准库函数。

- C 语言缺乏现代 PL 的语言特性，比如函数式编程，语言层级支持的类型推断、静态泛型等等。这一点就不多做赘述了，这篇文章不会讨论具体的语言特性；反正就是新的、好用的、被广泛接受的功能的匮乏，导致开发者写得越来越“不爽”。

## 心理学的游戏

```c
int a = 1;
const int b = 1;
```

```rs
let mut a = 1;
let b = 1;
```

上面是用 C 和 rust 编写得两个语句。它们的语义是完全相同的。a 是一个变量，b 是一个常量。rust 的选择是，默认为常量，如果声明一个变量，需要多写 `mut` 三个字符；C 语言则是，默认为变量，如果声明一个常量，需要多写 `const` 五个字符。

在 C/C++ 的开发过程中，最佳实践就是把所有具备常量语义的标识符前面加个 const 修饰，确保我们不会在后面编码的过程中忘记这件事。忘记了会导致什么情况？严重一点的，比如一个指针本来应该是常量语义的，但如果忘记加了常量修饰，我们又把它覆盖了，那就可能导致内存泄漏。C++ 的类成员函数也是如此，如果我们声明一个成员函数是 const 的，那么如果在编写这个函数的时候，编译器报错说我们修改了成员变量，那就说明我们写错了。

如果让开发者手动加 const，开发者可能有时会忘了这件事。但如果默认常量，让开发者手动加 mut，看似和之前的设计等效，实则是在用户做不安全操作时增大用户的成本，在安全操作下让用户享受最低成本。

人总是懒的、容易犯错的。越是现代些的编程语言，设计者越是通过种种方法，去匡正开发者的编码。以上是 rust 相较于它的前辈做出的一个小改进，这种“默认安全”的思想，贯穿了它的整个语言设计。

