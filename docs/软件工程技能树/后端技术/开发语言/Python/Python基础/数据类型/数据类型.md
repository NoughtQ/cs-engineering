---
title: 数据类型
slug: ruan-jian-gong-cheng-ji-neng-shu/hou-duan-ji-shu/kai-fa-yu-yan/python/python-ji-chu/shu-ju-lei-xing/shu-ju-lei-xing
sidebar_position: 1
---

# 数据类型

Author：邓焱

### 基础类型

### Lists

Python中的lists相当于c语言中的数组，对于访问越界的问题，Python会自动对越界的行为进行检查并报错

#### 基础知识

<b>创建空列表</b>
```py
my_list = []
```
列表的元素之间使用`,`进行分隔，列表的元素不一定是一种类型，一个列表可以包含不同元素类型
```py
# 创建一个简单的列表 
my_list = [1, 2, 3, 4] 
print(my_list)  # 输出: [1, 2, 3, 4]

# 创建一个包含不同类型元素的列表 
mixed_list = [1, "hello", 3.14, True] 
print(mixed_list)  # 输出: [1, 'hello', 3.14, True]
```
对于列表元素的访问，直接使用索引即可
```py
my_list = [10, 20, 30, 40]

# 访问第一个元素
print(my_list[0])  # 输出: 10

# 访问最后一个元素
print(my_list[-1])  # 输出: 40
```
Python的索引包含<b>负索引</b>，表示从右到左进行索引，上面的例子中，`my_list[-1]` 是最后一个元素。

#### 常见操作

<b>添加元素</b>
- 使用 `append()` 向列表添加一个元素。
- 使用 `extend()` 向列表添加多个元素。
- 使用 `insert()` 在特定位置插入元素。
```py
my_list = [10, 20, 30]

# 添加单个元素
my_list.append(40)
print(my_list)  # 输出: [10, 20, 30, 40]

# 添加多个元素
my_list.extend([50, 60])
print(my_list)  # 输出: [10, 20, 30, 40, 50, 60]

# 在指定位置插入元素
my_list.insert(2, 25)  # 在索引2的位置插入25
print(my_list)  # 输出: [10, 20, 25, 30, 40, 50, 60]
```

<b>删除元素</b>
- 使用 `remove()` 删除指定值的元素。
- 使用 `pop()` ，如果没有参数，默认删除最后一个元素，如果有参数，删除对应位置的元素。
- 使用 `del` 删除指定位置的元素。`del`是内置的关键字，专门用于删除对于对象的引用，不仅对列表元素，所有的Python对象都可以用del删除，当对象的引用计数变为0的时候，Python的垃圾回收机制就会自动销毁该对象（在面向对象的部分会深入讲解）
```py
my_list = [10, 20, 30, 40, 50]

# 删除指定元素
my_list.remove(30)
print(my_list)  # 输出: [10, 20, 40, 50]

# 删除并返回最后一个元素
last_element = my_list.pop()
print(last_element)  # 输出: 50
print(my_list)  # 输出: [10, 20, 40]

# 删除指定位置的元素
del my_list[1]
print(my_list)  # 输出: [10, 40]
```

<b>切片操作</b>
切片操作就是截取指定片段的列表，这里的<b>指定</b>就是我们给定的参数（起点，终点，步长），返回值一般是被切片对象的副本，但只是对原来列表的<b>浅层复制</b>。如果原来列表中的元素不是基本数据类型的话，复制得到的副本还是会共享原来列表中的对象。
对于三个参数而言，如果没指定起点，那么就默认从0开始，如果没有终点，那么就默认切片到最后的元素
```py
my_list = [10, 20, 30, 40, 50]

# 获取前3个元素
first_three = my_list[:3]
print(first_three)  # 输出: [10, 20, 30]

# 获取从索引2到最后的元素
from_second = my_list[2:]
print(from_second)  # 输出: [30, 40, 50]
```
第三个参数步长一般默认为1，并且不占位置，如果需要指明步长的话，那么写法如下
```py
#sequence[start:stop:step]
lst = [0, 1, 2, 3, 4, 5]
sub_lst = lst[1:4:2]
#[1,3,5]
```
同样的步长可以为负数，这时表示从后往前进行切片
```py
# 正常步长
lst = [0, 1, 2, 3, 4, 5]

# 负步长
print(lst[4:1:-1])  # 输出 [4, 3, 2]，从索引4到索引1（不包括1），步长为-1

# 负步长，逆序提取整个列表
print(lst[::-1])  # 输出 [5, 4, 3, 2, 1, 0]，反转列表
```
起点终点的大小关系也会对应改变。如果没有满足大小关系的话，也不会报错，只会返回空列表，表示对应的列表截取不到，为空。

<b>列表的长度</b>
`len()`函数是一个Python的内建函数，是通过调用对象的`__len__()`方法来获取长度的，只要你的Python对象有`__len()__`函数，那么该对象也可以使用`len()`函数
```py
class A(object):
    
    def __len__(self):
        print('A.__len__')
        return 10
    
a = A()
print(len(a))
#A.__len__
#10
```
关于更多的内建函数的`magic`方法，在面向对象中我们会详细讲到
```py
my_list = [10, 20, 30, 40]
print(len(my_list))  # 输出: 4
```

<b>检查元素是否在列表中</b>
当我们想查看某个元素是否在列表中的时候，我们可以简单地用循环来枚举，也可以<b>优雅地</b>使用`in`关键字，`in`关键字通过调用容器对象的内部方法来实现查找操作，也是枚举内部是否含有某元素
```py
#element in container  # 判断 element 是否在 container 中
my_list = [10, 20, 30, 40]
print(20 in my_list)  # 输出: True
print(50 in my_list)  # 输出: False
```

<b>列表排序和反转</b>
我们利用`sort()`函数来对列表进行排序，<b>注意</b>，`sort()`是列表对象地一个方法，采用<b>原地排序，</b>返回值为None，会修改原始列表，而我们前面讲的`sorted()`是Python的内建函数，返回的是一个新的列表，不修改原始列表
`sort`有两个参数，一个是`key`，一个是`reverse`
`key`：一个函数，用于从每个元素中提取一个用于比较的值。默认为 `None`，即直接比较列表中的元素。
`reverse`：一个布尔值，默认为 `False`。如果设置为 `True`，则列表会被倒序排序，即降序排列。
```py
#list.sort(key=None, reverse=False)
```
```py
lst = ["apple", "banana", "cherry", "date"]
lst.sort(key=len)
print(lst)  # 输出 ['date', 'apple', 'banana', 'cherry']，按照字符串的长度排序
```
```py
lst = [5, 2, 9, 1, 5, 6]
lst.sort(reverse=True)
print(lst)  # 输出 [9, 6, 5, 5, 2, 1]，按降序排序
```
`sort()` 函数在Python中是<b>稳定的排序算法</b>。<b>稳定</b>的意思就是，如果有多个元素的排序键相同，那么它们在排序后的列表中的相对顺序不会改变。
```py
lst = [(1, 'a'), (3, 'b'), (2, 'c'), (1, 'b')]
lst.sort(key=lambda x: x[0])  # 按第一个元素排序
print(lst)  # 输出 [(1, 'a'), (1, 'b'), (2, 'c'), (3, 'b')]，相同的第一个元素保持相对顺序
```
<b>时间复杂度</b>
`sort()` 函数使用的是<b>Timsort</b>算法（目前最快的排序算法），Timsort 是一种混合排序算法，结合了归并排序（Merge Sort）和插入排序（Insertion Sort）的优点。
下面这种排序算法的复杂度，看一下就可以了👍
- <b>最坏时间复杂度</b>：`O(n log n)`，当列表中元素的数量很大时，Timsort 的表现是最坏情况下仍然保持 `O(n log n)`。
- <b>平均时间复杂度</b>：`O(n log n)`。
- <b>空间复杂度</b>：`O(n)`，这是因为 Timsort 需要额外的空间来进行归并操作。
<b>复杂的排序例子</b>
我们可以使用之前的匿名函数来很<b>优雅地</b>进行一些比较复杂的排序
按元组的第二个元素排序：
```py
lst = [(1, 'apple'), (3, 'banana'), (2, 'cherry')]
lst.sort(key=lambda x: x[1])  # 按元组的第二个元素（字母顺序）排序
print(lst)  # 输出 [(1, 'apple'), (3, 'banana'), (2, 'cherry')]
```
按字符串的长度降序排序
```py
lst = ["apple", "banana", "cherry", "date"]
lst.sort(key=len, reverse=True)  # 根据字符串长度降序排序
print(lst)  # 输出 ['banana', 'cherry', 'apple', 'date']
```

#### 嵌套列表

#### 列表推导式

### Tuple

`tuple`类似于列表（`list`），但与列表不同，`tuple` 是<b>不可变</b>（immutable）的。`tuple` 用来存储多个元素，并且这些元素可以是不同类型的数据。因为元组是不可变的，所以它们在存储和访问时通常比列表更高效。

<b>创建元组</b>
```py
my_tuple = (1, 2, 3, 4)
print(my_tuple)  # 输出: (1, 2, 3, 4)
```
<b>创建单一元素的元组：</b>
创建包含单个元素的元组时，必须在元素后加一个逗号，否则 Python 会将其误认为是普通的括号表达式。
```py
single_element_tuple = (5,)  # 注意逗号
print(single_element_tuple)  # 输出: (5,)
```
如果没有逗号，那么会被认为是一个普通的数字或表达式，而不是元组：
not_tuple = (5)  # 这只是一个整数，不是元组
print(type(not_tuple))  # 输出: &lt;class 'int'&gt;
空元组不需要逗号
empty_tuple = ()

print(type(empty_tuple))  # 输出: &lt;class 'tuple'&gt;
<b>嵌套元组</b>
元组可以包含其他元组作为元素，从而创建多维结构。
```py
nested_tuple = (1, (2, 3), (4, 5))
print(nested_tuple[1])  # 输出: (2, 3)
print(nested_tuple[1][0])  # 输出: 2
```

<b>元组元素的访问和切片</b>
对于元组中的元素进行访问和切片时，操作和列表一样，唯一不同的是，<b>列表切片返回的是列表，元组切片返回的是元组</b>
```py
my_tuple = (1, 2, 3, 4)
print(my_tuple[0])  # 输出: 1
print(my_tuple[1])  # 输出: 2
print(my_tuple[-1])  # 输出: 4  (最后一个元素)
print(my_tuple[-2])  # 输出: 3  (倒数第二个元素)

# 获取索引从 1 到 3（不包含 3）的部分
print(my_tuple[1:3])  # 输出: (2, 3)

# 获取所有元素
print(my_tuple[:])  # 输出: (1, 2, 3, 4, 5)

# 获取每隔一个的元素
print(my_tuple[::2])  # 输出: (1, 3, 5)
```
切片返回值
```py
# 示例
t = (1, 2, 3, 4, 5)
l = [1, 2, 3, 4, 5]

print(t[1:4])  # 输出: (2, 3, 4)
print(l[1:4])  # 输出: [2, 3, 4]
```

<b>不可变性</b>
元组是不可变的，这意味着一旦元组创建后，你就不能修改它的内容。如果你尝试修改元组中的元素，会抛出 `TypeError`。
```py
my_tuple = (1, 2, 3)
# 尝试修改元组中的元素
# my_tuple[1] = 10  # 会抛出 TypeError: 'tuple' object does not support item assignment
```
可以重新创建一个新的元组
```py
my_tuple = (1, 2, 3)
new_tuple = my_tuple + (4,)
print(new_tuple)  # 输出: (1, 2, 3, 4)
```

<b>常用操作</b>
元组和列表的操作具有相似性，由于元组不可变，所以列表的所有对元素进行修改的操作元组都不适用，其他的获取对象信息的方法都是一样的。
#### 长度：`len()`
可以使用 `len()` 函数获取元组中的元素个数。
```py
my_tuple = (1, 2, 3, 4)
print(len(my_tuple))  # 输出: 4
```
#### 成员检查：`in` 和 `not in`
可以使用 `in` 和 `not in` 来检查元素是否存在于元组中。
```py
my_tuple = (1, 2, 3, 4)
print(3 in my_tuple)  # 输出: True
print(5 in my_tuple)  # 输出: False
```

<b>常见用法</b>
<b>函数返回多个值</b>：元组常用于函数返回多个值。
将元组的值赋给多个变量称为<b>解包</b>
返回时可以显式地写成元组，也可以直接返回多个变量隐式转化成元组
```py
def get_coordinates():
    return (10, 20)

x, y = get_coordinates()  # 解包
print(x, y)  # 输出: 10 20

def get_person_info():
    name = "Bob"
    age = 25
    return name, age

# 解包元组
name, age = get_person_info()
print(name)  # 输出: Bob
print(age)   # 输出: 25
```
<b>作为字典的键</b>：由于元组是不可变的，它们可以作为字典的键，而列表不能。
```py
my_dict = {}
my_dict[(1, 2)] = "value"
print(my_dict)  # 输出: {(1, 2): 'value'}
```

### Set

### dict

### immutable和mutable

### 类型转换

Python 提供了内置的类型转换函数，用于在不同数据类型之间进行转换。例如：

- `int()`：将其他数据类型转换为整数。
- `float()`：将其他数据类型转换为浮点数。
- `str()`：将其他数据类型转换为字符串。
- `list()`：将其他数据类型转换为列表。
- `tuple()`：将其他数据类型转换为元组。
- `set()`：将其他数据类型转换为集合。
- `dict()`：将符合要求的数据结构转换为字典。

