---
title: 单调队列优化动态规划
slug: 单调队列优化动态规划
sidebar_position: 0
---


# 单调队列优化动态规划

Author：周楷程

<div class="callout callout-bg-2 callout-border-2">
<div class='callout-emoji'>💡</div>
<p><b>前置知识要求：</b></p>
<ul>
<li><p>基本的动态规划原理</p>
</li>
<li><p>了解队列这一数据结构</p>
</li>
<li><p>时间复杂度的计算</p>
</li>
</ul>
</div>

# 什么是单调队列？

单调队列，顾名思义就是“单调”的“队列”。这里的单调可不是乏味的意思，而是单调递增(减)。

通过队列操作，我们维护这个队列中的元素始终是单调的，借此让我们快速获取到一些信息，完成优化。

先来看一道题目。

<div class="callout callout-bg-2 callout-border-2">
<div class='callout-emoji'>💡</div>
<p>本文没有给出任何代码，因为滑动窗口代码本身并不复杂，但需要一些思考。希望大家可以尝试先自己写一下。</p>
</div>

### [LeetCode 239 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

> 给你一个整数数组 `nums`，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
> 返回（每次）<em>滑动窗口中的最大值</em>。
> > - $$1 \leq k \leq n \leq 10^5$$
> > 示例：
> ```cpp
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

显然暴力是 $O(nk)$ 的，这不可接受。

那么考虑一下单调队列呢？

我们可以维护这个单调队列，使得它始终只存有此刻滑动窗口中的元素，并且保持其单调递减，这样我们每一时刻的答案就是队首元素。

怎么做到呢？

- <em>使得它始终只存有此刻滑动窗口中的元素</em>： 判断队首元素是否在窗口中，如果不在则弹出。直到队首元素位于窗口中。然后让进入滑动窗口的新元素从队尾入队。
- <em>保持其单调递减</em>：在新元素从队尾入队前，判断这个新元素是否大于等于当前队尾。如果是，则单调递减性质被破坏，需要弹出当前队尾。重复此过程直到队列为空或者当前队尾小于新元素。然后让新元素入队。

我们来模拟一下：

```cpp
滑动窗口的位置                 最大值   单调队列
---------------               -----   --------
                                      [] <= 1
                                      [1] <= 3
                                      [3] <= -1
[1  3  -1] -3  5  3  6  7       3     [<b>3</b>, -1]
 1 [3  -1  -3] 5  3  6  7             [3, -1] <= -3
                                3     [<b>3</b>, -1, -3]
 1  3 [-1  -3  5] 3  6  7             [-1, -3] <= 5
                                      [-1] <= 5
                                      [] <= 5
                                5     [<b>5</b>]
 1  3  -1 [-3  5  3] 6  7             [5] <= 3
                                5     [<b>5</b>, 3]
 1  3  -1  -3 [5  3  6] 7             [5, 3] <= 6
                                      [5] <= 6
                                      [] <= 6
                                6     [<b>6</b>]
 1  3  -1  -3  5 [3  6  7]            [6] <= 7
                                      [] <= 7
                                7     [<b>7</b>]
```

### 时间复杂度？

每个元素恰好遍历到一次、入队一次、出队一次。均摊 $O(n)$。

### 所以单调队列能干什么？

这一道题其实就是单调队列的最基本形态。它能做的就是求连续滑动窗口内的最值。

# 单调队列优化 DP

在做 DP 时，如果转移方程中存在区间最值，则可以考虑使用单调队列来进一步优化复杂度。

### [LOJ 10180 烽火传递](https://loj.ac/p/10180)

> 烽火台是重要的军事防御设施，一般建在交通要道或险要处。一旦有军情发生，则白天用浓烟，晚上有火光传递军情。
> 在某两个城市之间有 n 座烽火台，每个烽火台发出信号都有一定的代价。为了使情报准确传递，在连续 m 个烽火台中至少要有一个发出信号。现在输入 n, m 和每个烽火台的代价，请计算总共最少的代价在两城市之间来准确传递情报。
> > - $$1 \leq n, m \leq  2\times10^5$$
> > 样例输入
> ```
5 3
1 2 5 6 2
```
> 样例输出
> ```
4
```

首先有一个很显然的 DP：

$$f_i = \min^{i-1}_{j=i-k}f_j + c_i$$

可以看到转移的前半部分是滑动窗口最小值，使用单调队列优化即可。复杂度 $O(n)$。

### [LeetCode 1687 从仓库到码头运输箱子](https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports/)

> 你有一辆货运卡车，你需要用这一辆车把一些箱子从仓库运送到码头。这辆卡车每次运输有 <b>箱子数目的限制</b> 和 <b>总重量的限制</b> 。
> > 给你一个箱子数组 boxes 和三个整数 portsCount, maxBoxes 和 maxWeight ，其中 boxes[i] = [ports​​i​, weighti] 。
> > ports​​i 表示第 i 个箱子需要送达的码头， weightsi 是第 i 个箱子的重量。
> portsCount 是码头的数目。
> maxBoxes 和 maxWeight 分别是卡车每趟运输箱子数目和重量的限制。
> 箱子需要按照 <b>数组顺序</b> 运输，同时每次运输需要遵循以下步骤：
> > - 卡车从 boxes 队列中按顺序取出若干个箱子，但不能违反 maxBoxes 和 maxWeight 限制。
> - 对于在卡车上的箱子，我们需要<b> 按顺序</b> 处理它们，卡车会通过 <b>一趟行程</b> 将最前面的箱子送到目的地码头并卸货。如果卡车已经在对应的码头，那么不需要 <b>额外行程</b> ，箱子也会立马被卸货。
> - 卡车上所有箱子都被卸货后，卡车需要 <b>一趟行程</b> 回到仓库，从箱子队列里再取出一些箱子。
> 卡车在将所有箱子运输并卸货后，最后必须回到仓库。
> > 请你返回将所有箱子送到相应码头的 <b>最少行程</b> 次数。
> > $$1 \leq n \leq 10^5$$
> > 实例：
> 请前往 leetcode 页面。

这一题的 DP 也不复杂。

$$f_i = \max^{i-1}_{j=i-\text{maxBoxes}}f_j + C(j + 1, i)$$

同时，$j$需要满足 $\sum_{k=j+1}^i w_k\leq \text{maxWeight}$。

直接暴力计算的复杂度并不正确。考虑优化。

首先，我们来解决 $C$ 函数的计算。

$C(j+1, i)$ 表示把从第 $j+1$ 个到第 $i$个物品装箱运输一趟所需要耗费的行程次数。

观察可得，$C(j+1, i) = 2 + \sum_{k=j+1}^{i-1} [p_k \not= p_{k+1}]$。

这里有一个区间和，我们可以用前缀和优化。即，提前计算 $sc_i = \sum_{j = 1}^i[p_j \not= p_{j+1}]$，那么就有

$C(j+1, i) = 2 + sc_{i-1} - sc_j$，可以 $O(1)$ 计算。

再来观察前面的区间最大值。这类似于前面的滑动窗口最值，只不过窗口长度并不是定长的。

我们可以修改弹出队首的条件。设队首元素编号为 $l$，当前需要入队的元素编号为 $i$：

- 当 $l < i - \text{maxBoxes}$ 时，违反了装箱数量限制，应当弹出队首；
- 当 $\sum_{j=l+1}^i w_j > \text{maxWeight}$ 时，违反了装箱重量限制，应当弹出队首。

第一条可以 $O(1)$ 计算。第二条依然是一个区间和，使用前缀和优化，也可以 $O(1)$ 计算。

至此，我们可以使用单调队列计算转移方程的前半部分了。

综上，总复杂度 $O(n)$。

# 结语

DP 的优化方法有很多，单调队列仅仅是其中一种。做题时千万不要跳过 DP 先去思考怎么优化，还是应该先思考怎么 DP，怎么贪心，怎么暴力。毕竟 DP 题中，DP 才是重点。

滑动窗口题：[1695. 删除子数组的最大得分 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-erasure-value/)

