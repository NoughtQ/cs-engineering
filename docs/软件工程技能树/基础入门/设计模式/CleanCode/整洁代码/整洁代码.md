---
title: 整洁代码
slug: 整洁代码
sidebar_position: 0
---


# 整洁代码

# 勒布朗法则

> 稍后等于永不。(Later equals never)

我们都曾经认识到自己的程序写的很烂，但是我们又说，有一个烂程序总比没有强，因此我们决定有朝一日再回头来清理。

但是那是不可能的。你不会再去整理这坨屎山了。

# 混乱的代价

我们来讲一个故事。

有一个团队在项目初期的时候进展迅速，但是由于疏于代码的管理，结果在一两年后，开发开始变得缓慢，对于代码的每一次修改都要影响到其他两三处代码。这坨乱麻越来越大，到最后变得无法清理，变成屎山。

随着混乱的增加，团队的生产力下降了，而管理层就只能做一件事情：增加更多人手以期提高生产力。

但是<b>新人完全不熟悉整个系统</b>，他们完全搞不清楚怎样的修改是符合或者违背原本的设计的，再加上所有人都背负着提高生产力的可怕压力，于是新人只会添加更多的混乱。

最后，开发团队就造反了，他们告诉管理层，他们再也没法忍受维护这个屎山了，他们要求做全新的设计。管理层只好同意开发团队的请求，去做一套看上去华丽的新设计。

于是就组建了一个新团队，在新的白纸上重新复现这个项目。谁都想加入这个团队，但是只有最优秀和最聪明的家伙才会被选中，其他人则得继续维护屎山。

于是新团队和老团队开始同时开发，而新团队必须搭建一套新系统，不仅要实现老系统的所有功能，还要赶上老系统的所有持续改动，在新系统可以和老系统抗衡之前，管理层是不会替换掉老系统的。

这场双线程开发可能会持续很长的时间，甚至十几年。到了完成的时候，新团队的老成员早已不知去向，而现有的成员则要求重新设计一套更新的系统，因为<b>这套所谓的“新系统”太烂了</b>。

<b>所以保持代码的整洁不仅关乎效率，还关乎整个团队的生存。</b>

# 我们对甲方应该拥有的态度

> 写完就提桶跑路，岂不美哉（X）

我们总是会抱怨进度太紧张，没法干好活。我们把问题归咎于愚蠢的产品经理，苛刻的用户，但是这些都是不专业的表现。实际上写出屎山只是自作自受。

他们（甲方）指望从我们这边获得必需的信息，然后才能做出承诺和保证（推进进度），即使他们没开口问，我们也不应该羞于告知他们我们的想法。

多数甲方想要知道整个系统的真相，即使他们其实不喜欢真相；多数产品经理想要好代码，即使他们总是痴迷于进度问题。他们会奋力维护进度和需求，这是他们该干的，而你则<b>有责任以同样的热情维护代码</b>。

假设你是一名医生，即使病人请求你在给他做手术之前不要洗手，因为洗手很花时间，会拖慢进度，但是你会照办吗？你比他们更了解感染的风险，如果你照办了，这反而是一种不专业的做法。

> 1847年有个家伙提出了医生应该洗手的建议，但是当时遭到了反对，因为人们认为医生太忙，接诊的时候无暇洗手。（虽然在我们现在看来不可思议）

同理，程序员遵从那些不了解混乱风险的愚蠢甲方的意愿，也是不专业的做法。

> 虽然我的评级是：如果甲方真的够蠢而且够强硬，那就随他去吧。

# 代码需要易读

以前有个叫做Emac之类的编辑器可以记录每一次的按键动作。也就是说你可以在工作一小时后回放你的整个工作过程，就像在看一部高速电影，非常有趣。

如果你玩过这个功能的话，你就会发现，我们在写代码的时候。大多数时间是在读代码。

> Br进入code
> 他向下滚动到要修改的函数
> 他停下来考虑可以做什么
> 他滚动到code顶端，开始检查变量初始化
> 现在他回到修改处，开始输入
> 哦，他删除了输入的内容
> 他重新输入
> 他又删除了！
> 他输入了一半的东西，但是又删除了
> 他滚动到调用这个函数的函数，看看是怎么调用的
> 他回到了修改处，重新输入了刚才删掉的代码
> 他停了下来
> 他再一次删掉了那段代码
> 他打开了另一个窗口，查看别的子类。
> ......

事实上我们读与写的时间超过了10:1。在写新代码的时候，我们其实一直在读旧代码。

因此编写代码的难度，取决于读周边代码的难度。想要写得快，要先让代码易读。

# 童子军军规

> 让营地比你来时更干净。

# 如何看待书中的建议（如何看待所有的有关Clean Code的建议）

实际上，很多建议都存在争议。

或许你并不完全同意这些建议，甚至可能会强烈反对其中的一些建议。

<b>这样挺好的。</b>

