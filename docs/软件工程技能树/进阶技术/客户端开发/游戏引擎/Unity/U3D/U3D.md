---
title: U3D
slug: U3D
sidebar_position: 0
---


# U3D

Author：陈儒、陈岩、李嘉诚

Update : 2022.10

## 写在前面

这里写这个教程的目的并非你按照这里走一遍就能完美无缺的实现功能了，Unity是一个工程引擎，其必然需要手动操作才能体会到里面大部分的内容，我在这里写的很大一部分内容都是一个思考方式，写了Unity这样构造的合理性，以及Unity里面和其它开发流程的一些类比。我觉得大家在看的时候，最好能够抽象化里面的一部分内容，和自己以往学习到的各个方面的知识框架逻辑进行类比，而不只是看完后只能放在Unity本身上。比如说，假如你对数学的思想了解的比较深，那就硬往数学那边靠，进行比较，你会发现很多重复的思想的，这样学起来也比较快。

## Unity3D简介

### 什么是Unity3D

Unity3D是由Unity Technologies开发的一个让你轻松创建诸如三维视频游戏、建筑可视化、实时三维动画等类型互动内容的多平台的综合型游戏开发工具，是一个全面整合的专业游戏引擎。

Unity3D通过集成大量不同方面的功能：三维建模，动画制作，物理引擎，并将这些功能包装变更为组件后为开发者提供大量接口，以此为开发者提供一个综合化的开发平台。开发者只需要调用不同组件就能够简单实现一些物理效果和不同功能。

### 它能够应用的方面

物理模拟，简单软件构造，简单动画和建模，游戏。(其实主要都是游戏方面的）

## Unity3D平台的安装

### Unity版本管理器UnityHub

由于不同版本的Unity有不同的特性和功能，我们可能在不同场合下可能需要用到不同版本的Unity，因此在这里我推荐大家使用Unity Hub这个Unity管理平台安装不同版本的Unity。

![](/assets/DIGNbPmRQo8vM8xhhoac2GTvnRg.png)

<b>具体操作：</b>

左键按下`从Hub下载`，然后正常按流程走即可

### 开发者间的协作PlasticSCM

很明显，当我们开发软件，开发者之间必然需要一定协作。但是，我们知道游戏中往往充斥着大量的素材文件，对于大文件的管理git自己似乎并不很好支持，需要使用git-lfs。而当我们使用git-lfs时，由于Github等git-lfs服务都比较慢，为了能够快速提交下载，我们一般需要自行构造服务，这就导致了给开发者带来了不少的难题。为了解决这个问题，我们一般会使用Unity官方提供的PlasticSCM进行开发协作。

> 虽然如此，但我仍然要说PlasticSCM真的拉，服务器经常挂掉，而且有的选项会让你倍感迷惑导致丢掉一些代码，强建议在push前备份Assets文件夹。

### Nuget-For-Unity的安装

Nuget是.Net平台的一个很常用的扩展工具。它可以很方便的引入各种三方包和各种库插件。而Unity发展到目前，只剩下支持用C#语言进行脚本书写，那么我们也许需要一些包管理软件对项目的库插件进行管理。

![](/assets/SDLfbaGkCofLOVxb4slcJmBSnHf.png)

<b>大致操作：</b>

1.下载[此页面](https://github.com/GlitchEnzo/NuGetForUnity/releases)中的最新版本的*.unitypackages

2.下载后，右键该文件，并选择一个Unity版本进行打开(或者直接打开Unity的情况下进行左键单击)

## Unity简明教程

> 此块有部分是经验得出

### 项目的创建

> 万物有始

当我们打开UnityHub大概会面临这样一个界面

![](/assets/VWzmbZFh5oYbIpxfcnrcE4F9nhg.png)

看向右上角那个小蓝标，没错，它写着新项目，如果我们要开始一个新项目，那么只需要点击它就好了。

我们会发现里面有很多模板供我们选择，不同的模板会为你提供不同的预制软件包帮助开发，按理来说Unity一般是开发3D软件用的，因此我们一般都以3D模板为起点。

同时，在模板选项的右下角，会有版本管理选项，请确保选择您所在的工作组织进行远程仓库的创建。

### Unity界面

> 量在同类变换中不断变化，但我们会发现里面有一些东西或者说有些量之间的关系组合是不变的，我们定义其为变换中的不变量。

当我们打开Unity，大概会直面这样一个界面，也许这么多的工作区间会让你比较慌，但请不要慌。

![](/assets/IxCSb4bWwoAJIVxQZNqco89GnQh.png)

我们首先看到，这总体可以分为四部分，标号见上。当我们试图采用不同的窗口布局时，或者说进行一次窗口变换后，这几个同名窗的含义是不变的。

同时我们可以在上方的Window选单中进行调整。

下面我们简单介绍各个窗口中的内容:

1. `场景资源`：顾名思义，这个窗口用来观察当前场景中拥有的资源以及其层级顺序
2. `视图窗口`：这个窗口我们发现可以分为两个子窗，Scene和Game
    1. `Scene`：这是我们最主要操作的一个窗口，它起到审视场景内资源的3D位置，选择，等等重要的功能
    2. `Game`：这个窗口则是我们在运行时能够在不同Camera的Display下看到的窗口。

3. `综合窗口`：这个窗口虽然也有子窗口，并且可能有多个子窗口，但其一般肯定包含Project,Console,Plastic
    1. `Project`：其代表我们在该项目中的全部资源，比如一些外置库，安装包，图片，建模，等等，或者我们通过Assets选单Import的素材也全在此处
    2. `Console`：这个是我们调试脚本所观测的输出窗口
    3. `Plastic`：这个是我们在开启远程仓库时时Unity自身集成的Plastic插件，不过我们也可以通过直接运行PlasticSCM进行管理

4. `属性检视`：这个窗口我们会看到各个资源素材，或者说各个实例的可调参数，我们可以通过这里实例所带的组件提供的接口来调整实例的不同功能。(这个可能有点难以理解，我在下面将举个例子，不过这个一用你就懂了)

<b>例：Button的属性检视</b>

![](/assets/ZcqfbcUoooWo0Lx8pwWcNEbGnlg.png)

如上图，我们快速导入了一个Button。

当我们通过Heirachy层窗，或者Scene窗口选中了该Button后，在右侧的Inspector窗中就可以快速对其进行功能调整。

我们可以发现，一个Button的属性被划分出了多个不同的块(<em>注：我们将在下一节提到，这里的一块一块就是不同的Component或者说是我们写的脚本中的一个类。）</em>这里的每块中我们都可以调整让Button进行一些变换。

打个比方，我们改变Image中的SourceImage参数，那么我们就可以改变这个Button白白的背景。

其它也类似，强烈建议大家自己实操玩一玩。

### Unity组件

> 组件也许是Unity中的一个实例的最小单元。

这个其实和Vue中的差不多，很容易想象，如果我们直接写一大堆内容，那维护起来肯定复杂死了，而且还不能复用，因此我们进行功能的划分，只写一定功能的组件，然后通过不同组件的组合来得到一个更高级的功能。

> 或者我们也可以类比数学概念来理解，我们捞起沉淀已久的线性空间知识，如果我们将要实现的所有功能视为一个线性空间<em>(这个我感觉能证明出来，只要保证定义完善)，</em>那么我们一定能够找到一组基底的集合，通过一些线性组合就能表示出该线性空间的所有元素，而这个基底就是各个不同的组件。

Never Mind，上面的描述其实也不怎么重要，关键就是我们要体会到Unity用组件来进行功能划分的思想进行学习。

下面我们用一个例子讲一讲一个实例是如何进行组件拆解的。

<b>例：Button实例的组件构造</b>

![](/assets/RnxNbk9yAoaOUHx5ld8cI41nnih.png)

我们在上一节中提到，Button的不同功能可以通过里面的不同块的参数来进行调整，让我们应用组件的概念来理解下。

我们观察到，一个在场景中的Button其实可以分为右侧几个组件的叠加，我们对Button实例进行一次内容的详细拆解，其余实例可以类比。

> 符号定义：
> `——`：A——B表示A元素对应于B组件

首先知道一个Button必然有背景元素——Image，点击事件——Button

然后我们知道Button必然要渲染在Canvas上，那么必有渲染方式——Canvas Renderer

最后我们知道Button需要放置在3D场景内，那么则有场景中的不同几何变换——RectTransform

#### 组件的实现和使用

ababab，一般来说，有两种搭建方式，自己手撸脚本或者靠Unity的自带组件，一般来说Unity自带的比较抽象，但比较完备。

##### 手撸脚本的实现和使用

实现很简单，我们在Project窗上右键，Create——C#Script，然后开写就完事了。

这样出来的脚本模板如下

![](/assets/V3eobfXRCosGtDxr8FHcbuG1nec.png)

其中Update代表着每帧的执行内容，Start表示组件启用时的执行内容(<em>这些其实在下一小节组建的工作周期中将提到）</em>

然后当我们需要使用这个组件时，直接将它拖到实例上，或者在实例的属性窗口点击`Add Component`选中或搜索该组件即可。

##### 自带组件的使用

由于自带组件不需要我们写，所以我们直接调用它改变它提供的接口就好了

即在实例的属性窗口直接点击`Add Component`，选中需要的组件即可。

#### 组建的工作周期

首先插个官方的Doc(<b>注意版本)</b>

然后我们提取里面的一张图

![](/assets/T8T4brJnxoCdEoxzilxc57lcnFb.png)

这里其实我也不太了解，但以一般开发来说只要知道如下事实即可:


<b>Awake</b><b>&lt;</b><b>Enable一个组件</b><b>&lt;</b><b>Start</b><b>&lt;</b><b>Update</b><b>&lt;</b><b>Disable一个组件</b><b>&lt;</b><b>OnApplicationQuit</b>

#### 总结

在知道Unity组件的思想和概念后，其实已经能够通过学校学习的知识对付大部分的功能需求了，后面我们需要的其实是对于Unity自带组件特性的认知，以及一些Shader的写法啥的。这个Shader由于我本身不太了解原理因此后面会贴个到CG那边的链接

### Unity预制体(Prefab)

和组件概念类似，不过此时我们希望在一个更大的范围上进行功能的复用，比如一堆小人实例，那我们不可能每个小人实例都重复流程造一个，那我们就通过一个预先制定好的模板，每次改变一点点模板中的接口参数，来搞出不同的小人。

> 同样我们的也可以通过上面类似的类比数学概念，来表示其功能的完备性必可达到。

同样，我们要注意的是这里复用的思想，我们不希望做那么多的重复工作，因此才创造预制体。

#### 具体实现

我们在场景中创建好一个实例，然后把这个实例拖到Project窗口即可。

验证：此时应该会发现Hierarchy窗口中的那个实例变成蓝盒子图标。

### Unity测试

与其他软件开发类似，Unity里面也要进行测试，但是这个就比较复杂繁琐了，这部分主要防御测试那一章进行叙述。

可能还没写引述，但目前里面的第三方工具AltUnity肯定写了

## Unity自带组件和实例(Object)详解

诶呀，这部分实在太多了，而且各个版本其实都会不太一样，所以对于大部分我直接放个Manual手册，里面有一些需要其他知识的我细拉出来。<b>（注意区分里面的Unity工作原理和各个组件的细节，在本节中我们应当将注意放在组件细节上，如果要深入了解Unity原理则从上一节生命周期的那个Manual开始看）</b>

### UnityShader

大部分应该和CG内容相关，大家可以先看看。

## Unity一些技巧

这里其实大部分的内容，如果我们能够有时间看一遍Manual那必然能够自然的写出来，但是事实上是我们没有这么多时间来看manual，因此会有一些技巧需要我们查了以后才知道。

### Unity的三维模型

在unity中，所有三维面片都是单向的，这意味着，只有从面片正方向看过去，才能渲染和发生碰撞

由于不方便做面法线单向化，因而采取了一个【骚操作】：每个面都正反着来两次不就完了

### 三维重建

神奇地发现Unity渲染出来的效果和Pyvista渲染出来的效果竟然是不一样的，Pyvista可以正常渲染，而Unity的模型会带有奇怪的刺。

查了资料之后才知道，一个Unity物体最多支持的面只有65000个，多了的话渲染就会出问题。因此需要从三维重建的时候入手，解决点数和面数过多的问题。

#### 目前的解决方法

我试图查找Python可以使得面元数减少的方法，但是只找到了Pymeshlab。

Pymeshlab这个库必须导入正常的三维模型格式文件才能使用Filter，这和我们目前的文件格式明显是不符的。（目前的文件格式仅仅是json，不是很好转化成成熟的三维文件格式）

于是我请用了老朋友Pyvista，使用decimate方法来减少面元。最终效果良好且可以在unity中正常显示。

### U3D中的多边形绘制

首先使用的绘制工具很简单：Line Renderer组件，设置好Line Renderer的粗细之后，我们只需要控制组件的Positions这一数组即可。

### 鼠标坐标与Global坐标的关系

使用以下代码即可实现转换：

```csharp
Camera.main.ScreenToWorldPoint(Input.mousePosition)
```

### UI绘制

#### prefab制作

首先LeanGUI中含有很多的demo，因此可以从demo中获取一部分已经有的按钮等预制体。LeanGUI主要提供的是对原有元件的script进行增加，比如悬浮事件，颜色变换。

#### Button

按钮本身应该是一个component，但在创建UI游戏物体时自动生成的预制的样式。

其中Unity button包含的主要是一个OnClick和一些动画函数。这个局限性较大，并且动画比较难以调整。但是通过LeanButton脚本，其提供了OnClick ExitClick等接口，能够在相对应的事件发生时调用相关的物体，比如可以建立一个空物体，其中设定了多个调整Button内容的动画，那将其加入至LeanButton调用，则可执行一连串的动画。

#### Toggle

Toggle和Button类似，只是记录了Button的两个状态。

LeanToggle中分为了On和Off两个接口，也可分别在这两个状态编辑相应动画

#### Slider

通过动画来控制一个handle在滑条上的位置

其中颜色的填充和slider的粗细是通过一个大的有颜色的panel加上遮罩一样的东西做成的

##### 坑：

在更换handle样式时，这个handle是一个strech的图像，它的大小会随着父级控件而改变，因此如果要调整handle比如圆的大小，不能改变为绝对位置，需要通过改变Top和Down的相对距离来改。

在传递value参数时，除了脚本中的函数要加入一个float类型外，在slider接口处的函数需要选择Dynamic下的函数，不然不会传递value参数。

#### Icon

在做icon时发现，figma上下的png都是不透明的，而且在unity上没怎么找到svg的导入方式，所以目前采取的就是手动p成透明背景后加到组件的source image中。

最好将icon搞成白色，这样在动画的时候能够直接对其进行颜色的更改，不然得到的是不同颜色的叠加。

然后在对非同大小的物体加入icon时，需要选定border，如果不选定的话会是原图像的直接放大，选定了border后才能仍保留外部的border。

图片素材是不能直接放入到UI组件的source image中，需要先转化成Sprite(UI)(差不多这个名)。

在做按钮的时候，好像不同大小的圆形素材带来的button是有较大区别的，这个具体原因不怎么懂。

#### Scrollview 实现滚动列表

给content加上content size fitter和vertical/horizontal/grid layout group，可以实现自动将content子物体整齐排列，并将content的宽度/高度设置为子物体的总宽度/高度，以实现滚动条出现与否和长度对应变化。

Scroll sensitivity可以调节一次滚轮滚动多少

